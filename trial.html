<h2>Selection Sort Algorithm</h2>
<div class="algorithm-description">
    <p>Watch the algorithm in action with these colorful, animated bars!</p>
</div>

<!-- Visualization -->
<div class="visualization">
    <h3>Selection Sort Visualization</h3>
    <div class="graph-viewport">
        <div class="graph-container" id="selection-graph-container"></div>
    </div>
    <div class="controls">
        <button class="btn" id="selection-start-btn">üé¨ Start Sorting</button>
        <button class="btn btn-secondary" id="selection-reset-btn">üîÑ New Array</button>
        
        <div class="control-group">
            <span class="speed-control">
                <label>‚è±Ô∏è Speed: <span id="speed-value">Medium</span></label>
                <input type="range" id="selection-speed" min="100" max="1500" value="800">
            </span>
        </div>
        
        <div class="control-group">
            <span class="elements-control">
                <label>üìä Elements: <span id="elements-value">15</span></label>
                <input type="range" id="elements-count" min="5" max="50" value="15">
            </span>
        </div>
    </div>
    <p id="selection-status">Ready to sort! Click start to begin</p>
</div>

<script>
   // Configuration - Adjust these as needed
const CONFIG = {
    barWidth: 30,       // Default pixel width for each bar
    barGap: 6,          // Fixed gap between bars
    maxBars: 50,        // Maximum number of bars
    minValue: 10,       // Minimum bar height value
    maxValue: 100,      // Maximum bar height value
    heightScale: 2.2    // Vertical scaling factor
};

// Vibrant color palette
const COLORS = {
    default: '#3a86ff',
    compare: '#ff006e',
    min: '#8338ec',
    sorted: '#06d6a0',
    swap: '#ffbe0b'
};

// State management
let state = {
    array: [],
    sorting: false,
    speed: 800,
    maxElements: 10 // Default value
};

// Function to dynamically adjust barWidth based on the number of elements
function adjustBarWidth(elementCount) {
    const maxBarWidth = 35; // Maximum bar width
    const minBarWidth = 10; // Minimum bar width
    const maxElements = CONFIG.maxBars;

    // Calculate barWidth based on the number of elements
    CONFIG.barWidth = Math.max(
        minBarWidth,
        maxBarWidth - (elementCount - 10) // Reduce barWidth as elements increase
    );
}

// Generate new random array with growth animation
async function generateNewArray(size) {
    adjustBarWidth(size); // Adjust barWidth dynamically
    
    // Create new array with random values
    const newArray = Array.from({ length: size }, () =>
        Math.floor(Math.random() * (CONFIG.maxValue - CONFIG.minValue + 1)) + CONFIG.minValue
    );
    
    // If we're increasing the array size, animate the new elements growing in
    if (size > state.array.length) {
        // Start with the existing array (or empty if first run)
        const baseArray = state.array.length > 0 ? [...state.array] : [];
        
        // Fill the rest with height 0 for animation
        const animatedArray = [...baseArray];
        while (animatedArray.length < size) {
            animatedArray.push(0);
        }
        
        state.array = animatedArray;
        renderGraph();
        
        // Animate the new bars growing to their full height
        for (let i = baseArray.length; i < size; i++) {
            state.array[i] = newArray[i];
            renderGraph();
            await delay(100); // Speed of growth animation
        }
    } else {
        // For shrinking or same size, just update
        state.array = newArray;
        renderGraph();
    }
}

// Render the graph visualization with smooth transitions
function renderGraph(highlight = {}, sortedUpTo = -1) {
    const container = document.getElementById('selection-graph-container');
    container.innerHTML = '';
    container.style.width = `${calculateGraphWidth(state.array.length)}px`;
    
    state.array.forEach((value, index) => {
        const bar = document.createElement('div');
        bar.className = 'graph-bar';
        bar.style.width = `${CONFIG.barWidth}px`;
        bar.style.height = `${value * CONFIG.heightScale}px`;
        bar.style.backgroundColor = COLORS.default;
        bar.style.transition = 'height 0.3s ease, width 0.3s ease'; // Smooth transitions
        
        // Apply state-based styling
        if (index <= sortedUpTo) {
            bar.style.backgroundColor = COLORS.sorted;
            bar.classList.add('sorted');
        }
        if (index === highlight.minIndex) {
            bar.style.backgroundColor = COLORS.min;
            bar.classList.add('pulse');
        }
        if (highlight.compareIndices?.includes(index)) {
            bar.style.backgroundColor = COLORS.compare;
            bar.classList.add('wiggle');
        }
        if (index === highlight.swapIndex) {
            bar.style.backgroundColor = COLORS.swap;
            bar.classList.add('jump');
        }
        
        // Add value label
        const label = document.createElement('div');
        label.className = 'bar-label';
        label.textContent = value > 0 ? value : ''; // Hide label for zero-height bars
        bar.appendChild(label);
        
        container.appendChild(bar);
    });
}
</script>

